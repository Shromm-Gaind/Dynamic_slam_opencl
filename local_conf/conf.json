{
    // Debug options ////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    "tiff":false,//true,//false
    "png":true,

    // Setup openCL /////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    "kernel_files":["kernels_macros.h", "kernels.h", "kernels_photometric_cost.cl", "kernels_load_image.cl", "kernels_tracking.cl", "kernels_mapping.cl", "kernels_setup_keyframe.cl"],
                                                                        // array of kernel filenames

    // Input data ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    "data_file_increment":1,
    "data_file_offset":0,       //475;//10;//46;//462;//380;//0;

    // Load images //////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    "MipMap_margin":1,          //4
    "num_reductions":5,         //4                                     // Layers-1 of image pyramid in MipMap
    // gaussian_size 3                                                  // Box blurr size. Actually using 5x5 box in the code.

    "imagesPerCV":1,            //10,//20,//4,//30//4//7
    "max_frame_count":1,        //4,//30,//4,//140,//30,                // how many frames to run for. NB -1 -> run indefinitely.
    "max_opt_count":5,          //5,//60,
    "max_inner_opt_count":10,   //10,
    "cameraMatrix":[481.20,   0.0,  319.5, 	0.0,  480.0,  239.5, 	0.0,    0.0,    1.0],

    // Mapping parameters - DTAM ////////////////////////////////////////////////////////////////////////////////////////////////////
    "regularizer_outer_iter":30,
    "regularizer_inner_iter":10,
    "layers":64,                 //7;//32;//64;//128;//256//255;        // Layers of CostVol. Coarse to fine warping may allow few layers to be selected. Need to store the range.
                                                                        // Also keep layers for for depths across edge boundaries.
    "invert_GT_depth":true,                                             // 'true' if ground truth depth needs to be inverted.  
    "max_depth":450.0,                                                  // See values in DTAM_mapping/input/*.json file for each dataset.
    "min_depth":70.0,           //70.0;//3289.0;
    "occlusionThreshold":0.05,
    "startAt":0,

    "initialCost":1.0,          //3.0,
    "initialWeight":0.0000001,  // 0.00006103515625 smallest positive normal number in FP16

    "thetaStart":0.2,           //0.2;		//200.0*off;                // DTAM paper & DTAM_Mapping has Theta_start = 0.2
    "thetaMin":9.9e-8,          //1.0e-4;	//1.0*off;                  // DTAM paper NB theta depends on (i)photometric scale, (ii)num layers, (iii) inv_depth scale
    "thetaStep":0.87,

    "beta_g": 1.5,              //my dtam_opencl 1.5                    // NB alpha_g & beta_g depend on image gradient &=> pixel value range. Here range 0.0-1.0
    "alpha_g":15,               // can vary 15 to 0.15  // 0.015        // DTAM paper beta for optimization, (not for g1 edges): beta=0.001 while theta>0.001, else beta=0.0001  
                                                                        // used in __kernel void CacheG4, with correction for CV_8UC3 -> CV_32FC3
    "epsilon":1.0e-4,                                                   // used in __kernel void UpdateQD	
    "lambda":1.0,                                                       // used in __kernel void UpdateA2
    "L":4.0,                                                            // used in CostVol computeSigmas
    "scale_E_aux":10000,        //1.0;                                  // from DTAM_Mapping input/json/icl_numin.json

    // Tracking parameters //////////////////////////////////////////////////////////////////////////////////////////////////////////
    "SE3_LM_A":0.1,                                                     // LM damped least squares parameters for SE3 tracking  - currently not in use.
    "SE3_LM_B":0.1,
    "SE3_start_layer":5,
    "SE3_stop_layer":1,
    "SE_iter_per_layer":5,      //5
    "SE_iter":25,                //1 //10
    "SE_factor":0.003,          //0.5
    "SE_factor_iter_multiplier":0.9,
    "SE_factor_layer_multiplier":0.75,

    "SE3_Rho_sq_threshold":[[0.02,0.02,0.02] ,[0.02,0.02,0.02] ,[0.02,0.02,0.02] ,[0.02,0.02,0.02] ,  [0.02,0.02,0.02] ,[0.02,0.02,0.02]  ], // [layer 0-5][channel hsv]
    "SE3_update_dof_weights":[-1, -1, -1, -1, -1, -1],                 // -1, -1, -1  // 0, 0, 0, -100, -100, -1 // -1, -1, -1, -2000, -2000, -2000
    "SE3_float update_layer_weights":[1, 1, 1, 1, 1, 1],

    "SO3_delta_theta":1.0,                                              // radians 0.01 = 0.57 degrees
    "ST3_delta":1.0,                                                    // NB depends on depth scale, see max & min depth in mapping params.

    "Artif_pose_err_bool":true,
    "Artif_pose_err_algebra":[0.10,  0.0,  0.0,      0.0,  0.0,  0.0],// SO3 in Radians, ST3 in world units ? Pseudo exp / Log   //  0.10,  0.0,  0.0,      5.0,  -10.0,  0.0
                                                                        // See A tutorial on SE(3) transformation parameterizations and on-manifold optimization
                                                                        // Jos√© Luis Blanco-Claraco     doi.org/10.48550/arXiv.2103.15980
    "Artif_pose_err_axis":0,                                            // [0-5] rot xyz, trans xyz , in world coords, where x=   , y= up,  z= forward ?
    "Artif_pose_err_factor":2,
    "":"",
    // Results display //////////////////////////////////////////////////////////////////////////////////////////////////////////////
    "sample_layer":2,                                                   // Generate composite image of multiple iterations, sampling this layer from the mipmap.
    "sample_se3_incr":true,
    "":""
}
